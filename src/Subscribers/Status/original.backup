<?php

namespace App\Listeners\Complaints;

use App\Complaint;
use App\ComplaintComments;
use App\Jobs\Complaints\ComplaintCancelJob;
use App\Jobs\Complaints\ComplaintDelayJob;
use App\Jobs\Complaints\ComplaintForwardedJob;
use App\Jobs\Mails\CommentEmailJob;
use App\Models\Operation\ComplaintAssignment;
use App\Models\Organization\Department;
use Carbon\Carbon;
use Illuminate\Foundation\Bus\DispatchesJobs;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Support\Facades\Log;

class MonitorListener implements ShouldQueue
{
    use DispatchesJobs;

    public function onComplaintPending(Complaint $complaint)
    {
        Log::info('OnComplaintPending triggered on behalf of complain#'.$complaint->complain_no);
        $this->dispatch((new ComplaintCancelJob($complaint))->delay(Carbon::now()->addDay(2)));
    }

    public function onComplaintInProcess(Complaint $complaint)
    {
        Log::info('OnComplaintInProcess triggered on behalf of complain#'.$complaint->complain_no);
        $this->dispatch((new ComplaintDelayJob($complaint))->delay(Carbon::now()->addDay(5)));
    }

    public function onComplaintForwarded(Complaint $complaint)
    {
        Log::info('OnComplaintForwarded triggered on behalf of complain#'.$complaint->complain_no);
        $this->dispatch((new ComplaintForwardedJob($complaint)));
    }

    public function onComment(ComplaintComments $comment)
    {
        Log::info('OnComment triggered on behalf of complain comment#'.$comment->serial .' on complaint#'. $comment->complaint->complain_no);
        $comment_type = 'update';
        if($comment->status != $comment->last_status){
            switch($comment->state->short_code){
                case 'validate':
                    $comment_type .= '.status.validate';
                    break;
                case 'pending':
                    //event('complaint.status.pending', $comment->complaint);
                    $comment_type .= '.status.pending';
                    break;
                case 'discard':
                    $comment_type .= '.status.cancelled';
                    break;
                case 'forwarded.department':
                    $comment_type .= '.status.forwarded';
                    break;
                case 'assigned.staff':
                    $comment_type .= '.status.assigned';
                    break;
                case 'in.process':
                    $comment_type .= '.status.inprocess';
                    break;
                case 'reschedule':
                    $comment_type .= '.status.reschedule';
                    break;
                case 'staff.attended':
                    $comment_type .= '.status.attended';
                    break;
                case 'staff.delayed':
                    $comment_type .= '.status.delayed';
                    break;
                case 'resolved':
                    $comment_type .= '.status.resolved';
                    break;
            }
        }
        if($comment->user_id != $comment->complaint->user_id)
            $this->dispatch((new CommentEmailJob($comment, $comment->complaint->user, $comment_type)));

        foreach($comment->complaint->assignments as $assignment){
            if(!in_array($comment->user_id, $assignment->employee->users->lists('id')->toArray()))
                $this->dispatch((new CommentEmailJob($comment, $assignment->employee, 'update.department')));
        }
    }

    public function subscribe($events)
    {
        $events->listen(
            'complaint.status.pending',
            'App\Listeners\Complaints\MonitorListener@onComplaintPending'
        );

        $events->listen(
            'complaint.status.inProcess',
            'App\Listeners\Complaints\MonitorListener@onComplaintInProcess'
        );

        $events->listen(
            'complaint.status.forwarded',
            'App\Listeners\Complaints\MonitorListener@onComplaintForwarded'
        );

        $events->listen(
            'complaint.comment',
            'App\Listeners\Complaints\MonitorListener@onComment'
        );
    }
}
